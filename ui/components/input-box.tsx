"use client"

import type React from "react"
import { useCallback, useState } from "react"
import { useAppDispatch, useAppSelector } from "../store"
import {
  setMode,
  setTask,
  generatePlan,
  selectHasSteps,
  selectSteps,
  selectTask,
  selectMode,
} from "../store/plan-slice"
import { Button } from "../components/ui/button"

// Lazy import to keep initial bundle smaller
async function getJSZip() {
  const mod = await import("jszip")
  return mod.default
}

export default function InputBox() {
  const dispatch = useAppDispatch()
  const task = useAppSelector(selectTask)
  const mode = useAppSelector(selectMode)
  const hasSteps = useAppSelector(selectHasSteps)
  const steps = useAppSelector(selectSteps)

  const [downloading, setDownloading] = useState(false)

  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault()
      if (!task.trim()) return
      dispatch(generatePlan({ task, mode }))
    },
    [dispatch, task, mode],
  )

  const onDownload = useCallback(async () => {
    try {
      setDownloading(true)
      const JSZip = await getJSZip()
      const zip = new JSZip()

      // Project skeleton folder
      const root = zip.folder("traycer-project")
      if (!root) return

      // Add enhanced README with better formatting
      const feedbackSummary = steps
        .map((s, i) => {
          const feedbackIcon = s.feedback === "works" ? "✅" : s.feedback === "doesnt-work" ? "❌" : "⚪"
          return `${i + 1}. ${feedbackIcon} ${s.title}`
        })
        .join("\n")

      const summary = [
        `# ${task ? task.charAt(0).toUpperCase() + task.slice(1) : "Generated Project"}`,
        ``,
        `> Generated by Traycer AI - ${new Date().toLocaleDateString()}`,
        ``,
        `## Project Overview`,
        `**Task:** ${task || "(no task provided)"}`,
        `**Mode:** ${mode}`,
        `**Total Steps:** ${steps.length}`,
        ``,
        `## Implementation Steps`,
        feedbackSummary,
        ``,
        `## Getting Started`,
        `1. Review each step in the numbered folders`,
        `2. Follow the implementation guide in each step's README`,
        `3. Adapt the code to your specific requirements`,
        ``,
        `## Feedback Legend`,
        `- ✅ Tested and works`,
        `- ❌ Issues reported`,
        `- ⚪ Not yet evaluated`,
        ``,
        `---`,
        `Generated with ❤️ by Traycer MVP`,
      ].join("\n")
      root.file("README.md", summary)

      // Add project structure file
      const projectStructure = [
        `# Project Structure`,
        ``,
        `This project contains ${steps.length} implementation step(s):`,
        ``,
        ...steps.map((s, i) => {
          const folderName = `${String(i + 1).padStart(2, "0")}-${s.title
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, "-")
            .replace(/(^-|-$)/g, "")}`
          return `- \`${folderName}/\` - ${s.title}`
        }),
        ``,
        `Each folder contains:`,
        `- README.md - Step description and implementation notes`,
        `- Code files - Ready-to-use implementation`,
      ].join("\n")
      root.file("PROJECT_STRUCTURE.md", projectStructure)

      // Enhanced step folders with better structure
      steps.forEach((s, i) => {
        const stepFolderName = `${String(i + 1).padStart(2, "0")}-${s.title
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/(^-|-$)/g, "")}`
        const stepFolder = root.folder(stepFolderName)
        if (!stepFolder) return

        // Enhanced step README
        const stepReadme = [
          `# Step ${i + 1}: ${s.title}`,
          ``,
          s.feedback ? `**Status:** ${s.feedback === "works" ? "✅ Tested - Works" : "❌ Issues Reported"}` : "**Status:** ⚪ Not yet evaluated",
          ``,
          `## Description`,
          s.detail || "Implementation step for the project.",
          ``,
          `## Implementation`,
          s.code ? `See the code file: \`main.${s.language || "py"}\`` : "No code provided for this step.",
          ``,
          `## Next Steps`,
          `1. Review the code implementation`,
          `2. Test the functionality`,
          `3. Adapt to your specific requirements`,
          s.feedback !== "works" ? `4. Debug any issues if encountered` : "",
        ].filter(Boolean).join("\n")
        
        stepFolder.file("README.md", stepReadme)
        
        if (s.code) {
          const fileExtension = getFileExtension(s.language || "python")
          stepFolder.file(`main.${fileExtension}`, s.code)
          
          // Add a simple package.json for JavaScript/TypeScript projects
          if (s.language === "javascript" || s.language === "typescript" || s.language === "tsx" || s.language === "jsx") {
            const packageJson = {
              name: `step-${i + 1}`,
              version: "1.0.0",
              description: s.title,
              main: `main.${fileExtension}`,
              scripts: {
                start: "node main.js",
                dev: "nodemon main.js"
              }
            }
            stepFolder.file("package.json", JSON.stringify(packageJson, null, 2))
          }
        }
      })

      const blob = await zip.generateAsync({ type: "blob" })
      const url = URL.createObjectURL(blob)
      const a = document.createElement("a")
      a.href = url
      a.download = `${task ? task.replace(/[^a-zA-Z0-9]/g, "-") : "traycer-project"}.zip`
      document.body.appendChild(a)
      a.click()
      a.remove()
      URL.revokeObjectURL(url)
    } finally {
      setDownloading(false)
    }
  }, [steps, task, mode])

  // Helper function to get appropriate file extension
  const getFileExtension = (language: string): string => {
    const extensions: Record<string, string> = {
      javascript: "js",
      typescript: "ts",
      tsx: "tsx",
      jsx: "jsx",
      python: "py",
      java: "java",
      cpp: "cpp",
      c: "c",
      csharp: "cs",
      php: "php",
      ruby: "rb",
      go: "go",
      rust: "rs",
      swift: "swift",
      kotlin: "kt",
      html: "html",
      css: "css",
      scss: "scss",
      sql: "sql",
      bash: "sh",
      shell: "sh",
      markdown: "md",
      json: "json",
      yaml: "yml",
      xml: "xml",
    }
    return extensions[language.toLowerCase()] || "txt"
  }

  return (
    <form onSubmit={handleSubmit} className="rounded-lg border border-border bg-card p-4">
      <label htmlFor="task" className="mb-2 block text-sm font-medium">
        Coding Task
      </label>
      <input
        id="task"
        name="task"
        placeholder={'e.g. "Build a todo UI that calls an external REST API"'}
        className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus:ring-2 focus:ring-ring"
        value={task}
        onChange={(e) => dispatch(setTask(e.target.value))}
      />

      <div className="mt-4 flex items-center gap-2">
        <span className="text-sm text-muted-foreground">Agent:</span>
        <div className="inline-flex items-center gap-2 rounded-md border border-border p-1">
          <Button
            type="button"
            variant={mode === "planner" ? "default" : "ghost"}
            className={mode === "planner" ? "bg-primary text-primary-foreground" : ""}
            onClick={() => dispatch(setMode("planner"))}
          >
            Planner
          </Button>
          <Button
            type="button"
            variant={mode === "normal" ? "default" : "ghost"}
            className={mode === "normal" ? "bg-primary text-primary-foreground" : ""}
            onClick={() => dispatch(setMode("normal"))}
          >
            Normal
          </Button>
        </div>

        <div className="ml-auto flex items-center gap-2">
          <Button type="submit" className="bg-primary text-primary-foreground">
            Generate
          </Button>
          <Button type="button" variant="secondary" disabled={!hasSteps || downloading} onClick={onDownload}>
            {downloading ? "Preparing…" : "Download Skeleton"}
          </Button>
        </div>
      </div>

      <p className="mt-2 text-xs text-muted-foreground">
        We attempt to call an external API configured via NEXT_PUBLIC_PLAN_API_URL (default{" "}
        {'"http://localhost:8000/api/v1/planner"'}). If it is unreachable, we fall back to mocked data so you can preview the
        UI flow.
      </p>
    </form>
  )
}
